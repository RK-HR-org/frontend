# Почему результат поиска некорректный: разбор сессии approve → execute

## Как проходит сессия поиска

1. **Create** — фронтенд создаёт сессию (`createSession`), бэкенд возвращает `enriched_filters`; форма подставляется из `applyEnrichedToForm(enriched_filters)`.
2. **Approve** — пользователь нажимает «Подтвердить»; фронтенд отправляет текущие фильтры формы как `hh_request` в `approveSession(session_id, { hh_request })`.
3. **Execute** — вызывается `executeSession(session_id, { page: 0 })`; бэкенд дергает HH API с тем `hh_request`, который **сохранён в сессии** (т.е. тем, что вернулся в ответе approve).

## В чём проблема

**На approve вы отправляете один `hh_request`, а в ответе (и при execute) используется другой — сокращённый и с изменённой семантикой.**

По снимку из `test.md`:

### Что уходит в запросе approve (payload)

- **textQueries: 15 элементов**, например:
  - «главный бухгалтер», `field: "experience_position"`, `logic: "all"`, `period: "last_three_years"`
  - плюс отдельные условия по навыкам (skills), опыту (experience_position, experience_company, experience_description) с нужными `field` / `logic` / `period`.

### Что возвращается в ответе approve в `hh_request`

- **textQueries: только 6 элементов**, при этом:
  - Часть условий **объединена** или **выброшена** (15 → 6).
  - У части условий **изменён `field`**: например, «налоговые проверки», «взаимодействие с аудиторами», «1С:Бухгалтерия 8.3» приходят с `field: "experience_description"` и `logic: "any"`, хотя в запросе они могли быть в `skills` с `logic: "all"`.
  - Меняются **`logic`** (all → any) и **`period`** (в т.ч. last_three_years → all_time).

Именно этот **сохранённый** `hh_request` (из ответа approve) бэкенд использует при **execute**. В HH API уходит уже не ваша исходная конфигурация, а скомпилированная на бэкенде версия.

## Почему результат «некорректный»

- Вы ожидаете поиск по **всем 15 текстовым условиям** с заданными полями и логикой.
- Фактически выполняется поиск по **6 условиям**, причём с другими полями и логикой (например, поиск по `experience_description` с `any` вместо поиска по `skills` с `all`).
- Семантика фильтра меняется → другой набор резюме и другая точность (часто больше лишних или меньше релевантных).

То есть причина некорректного результата — **не фронтенд и не HH API сами по себе**, а то, что **бэкенд подменяет переданный на approve `hh_request` своей скомпилированной версией** (сокращение числа textQueries и изменение field/logic/period).

## Что проверить на бэкенде

1. **Сохраняется ли переданный в approve `hh_request` как есть**  
   Если да — при execute должен уходить ровно он. Если нет — где и зачем он перезаписывается (ограничение HH по числу textQueries, «оптимизация», маппинг полей и т.п.)?

2. **Если есть лимит HH на число textQueries**  
   Тогда нужно либо:
   - не менять семантику при сокращении (объединять только логически эквивалентные условия),  
   - либо явно документировать/показывать пользователю, что будет реально отправлено в HH (например, показывать итоговый `hh_request` перед execute).

3. **Маппинг skills → experience_description и all → any**  
   Такой маппинг сильно меняет результат. Имеет смысл либо не менять field/logic по отношению к запросу пользователя, либо делать это только по явным правилам с документированием.

## Краткий вывод

- **Фронтенд** формирует и отправляет на approve полный `hh_request` (в т.ч. 15 textQueries) из текущего состояния формы.
- **Бэкенд** в ответе approve возвращает (и затем использует при execute) **другой** `hh_request` — с 6 textQueries и изменёнными field/logic/period.
- Некорректный результат возникает из‑за этой подмены: в HH уходит не тот запрос, который вы подтвердили. Исправление — на стороне бэкенда: либо сохранять и использовать переданный `hh_request` без изменения, либо гарантировать, что «скомпилированный» вариант семантически эквивалентен запросу пользователя.
